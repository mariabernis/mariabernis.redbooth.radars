 [
  {
  "type": "Task",
  "created_at": 1417735184,
  "updated_at": 1417735184,
  "id": 15865430,
  "name": "6A1052d: LLDB autocomplete misses some category declarations",
  "task_list_id": 2691300,
  "comments_count": 0,
  "assigned_id": null,
  "is_private": false,
  "project_id": 1332213,
  "urgent": false,
  "user_id": 1006184,
  "position": 0,
  "last_activity_id": 72897653,
  "record_conversion_type": null,
  "record_conversion_id": null,
  "metadata": {},
  "subtasks_count": 0,
  "resolved_subtasks_count": 0,
  "watcher_ids": [
                  1006184
                  ],
  "description": "rdar://15394622\r\n\r\nSummary:\r\nLLDB sometimes fails to autocomplete category methods depending on where they appear in the source. It appears that anything declared before the target class' @implementation is processed makes the cut, whereas anything declared after it, or not explicitly imported before it, does not.\r\n\r\nThe attached project has a number of schemes/targets to illustrate a number of scenarios that do and don't trigger autocompletion from the LLDB prompt in Xcode 6.1 (6A1052d)\r\n\r\nSteps to Reproduce:\r\n1. Check out or download the LLDBSymbols project at https://github.com/drance/radars/tree/LLDBSymbols\r\n2. Select a scheme, e.g. \"InternalCategory-NoInterface\"\r\n3. Run the project\r\n4. Tap the 'Press Here' button\r\n5. When LLDB prompt appears, type 'p [self inter' and wait. You should be offered the \"internalMethod\" symbol which appears in the view controller's implementation.\r\n6. Type 'p [self cat' and wait. Depending on the target (see below), you may or may not get autocompletion.\r\n\r\nEach scheme in the project corresponds to a different target using a variation of the main View Controller, each with a shared breakpoint that you should hit whenever you press the button.\r\n\r\nThe various implementation files, such as \"ViewControllerNoInterface.m\", has instructions in the -breakAction: method where the breakpoint is set. So, when you hit the breakpoint, and the LLDB prompt appears, you should be staring at instruction comments on what to do.\r\n\r\nExpected Results:\r\nExpect to always be offered 'categoryMethod' as autocompletion for '[self cat'\r\n\r\nActual Results:\r\nAutocompletion for the category method only happens if the conditions outlined in the problem description are met. As of 6A1052d, the targets / schemes that succeed are:\r\n\r\nInternalCategory-EarlyInterface\r\nInternalCategory-EarlyImplementation\r\nExternalCategory-Import\r\n\r\nThe others fail.\r\n\r\nVersion:\r\n6.1 (6A1052d) on 10.10.1 (14B25)",
  "description_html": "<p>Summary:<br>LLDB sometimes fails to autocomplete category methods depending on where they appear in the source. It appears that anything declared before the target class' @implementation is processed makes the cut, whereas anything declared after it, or not explicitly imported before it, does not.</p><p>The attached project has a number of schemes/targets to illustrate a number of scenarios that do and don't trigger autocompletion from the LLDB prompt in Xcode 6.1 (6A1052d)</p><p>Steps to Reproduce:<br>1. Check out or download the LLDBSymbols project at <a href=\"https://github.com/drance/radars/tree/LLDBSymbols2\">https://github.com/drance/radars/tree/LLDBSymbols2</a>. Select a scheme, e.g. \"InternalCategory-NoInterface\"3. Run the project4. Tap the 'Press Here' button5. When LLDB prompt appears, type 'p [self inter' and wait. You should be offered the \"internalMethod\" symbol which appears in the view controller's implementation.6. Type 'p [self cat' and wait. Depending on the target (see below), you may or may not get autocompletion.</p><p>Each scheme in the project corresponds to a different target using a variation of the main View Controller, each with a shared breakpoint that you should hit whenever you press the button.</p><p>The various implementation files, such as \"ViewControllerNoInterface.m\", has instructions in the -breakAction: method where the breakpoint is set. So, when you hit the breakpoint, and the LLDB prompt appears, you should be staring at instruction comments on what to do.</p><p>Expected Results:<br>Expect to always be offered 'categoryMethod' as autocompletion for '[self cat'</p><p>Actual Results:<br>Autocompletion for the category method only happens if the conditions outlined in the problem description are met. As of 6A1052d, the targets / schemes that succeed are:</p><p>InternalCategory-EarlyInterface<br>InternalCategory-EarlyImplementation<br>ExternalCategory-Import</p><p>The others fail.</p><p>Version:<br>6.1 (6A1052d) on 10.10.1 (14B25)</p>",
  "description_updated_by_user_id": 1006184,
  "updated_by_id": null,
  "deleted": false,
  "row_order": 0,
  "status": "open",
  "due_on": null
  },
  {
  "type": "Task",
  "created_at": 1417735187,
  "updated_at": 1417735187,
  "id": 15865431,
  "name": "SLComposeViewController hides Twitter auth errors",
  "task_list_id": 2691300,
  "comments_count": 0,
  "assigned_id": null,
  "is_private": false,
  "project_id": 1332213,
  "urgent": false,
  "user_id": 1006184,
  "position": 0,
  "last_activity_id": 72897656,
  "record_conversion_type": null,
  "record_conversion_id": null,
  "metadata": {},
  "subtasks_count": 0,
  "resolved_subtasks_count": 0,
  "watcher_ids": [
                  1006184
                  ],
  "description": "rdar://15394622\r\n\r\nSummary:\r\nSLComposeViewController has no error structure for reporting bad twitter credentials (HTTP 401 from Twitter), and does not provide useful information to the user when it fails.\r\n\r\nI have multiple accounts in Settings > Twitter: one authenticated, the other not. Presumably because I have one account logged in, [SLComposeViewController isAvailableForServiceType: SLServiceTypeTwitter] returns YES.\r\n\r\nIf I then select the unauthorized account and try to tweet, I get a vague \"connection to Twitter failed\" message. The console, however, reports that a 401 auth error came back from Twitter.\r\n\r\nThere are two problems here:\r\n\r\n1) The user isn't told how to fix the problem (Go to Settings > Twitter and re-enter user/pass)\r\n2) The API does report or return errors\r\n\r\nSo neither the developer nor the user are receiving the information they need to improve the situation.\r\n\r\nIt's also unclear how this happens in the first place. Settings does not let you save a Twitter account without successfully authenticating, so it sounds like someone is resetting auth tokens after the fact. Whether this is iOS (device-side) or Twitter (server-side) is unclear, but it spans versions and devices. I have other devices that are working just fine with all accounts.\r\n\r\nVerified on:\r\n\r\niPhone 5, iOS 6.1.4\r\niPhons 5s, iOS 7.0.2\r\n\r\nSteps to Reproduce:\r\n1. Add multiple accounts to Settings > Twitter\r\n2. Break or expire credentials for one of the accounts (unclear how or why this can happen)\r\n3. Try tweeting a photo from Photos / Camera with the broken account\r\n\r\nExpected Results:\r\nExpect the tweet to work, or to see actionable information on how to fix the auth problem.\r\n\r\nActual Results:\r\n\"The tweet cannot be sent because the connection to Twitter failed.\" (see attached pic)\r\n\r\nAlso attached device log output reporting the 401 auth failure from Twitter.\r\n\r\nVersion:\r\niPhone 5, iOS 6.1.4\r\niPhons 5s, iOS 7.0.2\r\n\r\nNotes:\r\nSavvy users will be able to experiment and figure out what's wrong, but this could be a lot better on both user and API fronts.",
  "description_html": "<p>Summary:<br>SLComposeViewController has no error structure for reporting bad twitter credentials (HTTP 401 from Twitter), and does not provide useful information to the user when it fails.</p><p>I have multiple accounts in Settings &gt; Twitter: one authenticated, the other not. Presumably because I have one account logged in, [SLComposeViewController isAvailableForServiceType: SLServiceTypeTwitter] returns YES.</p><p>If I then select the unauthorized account and try to tweet, I get a vague \"connection to Twitter failed\" message. The console, however, reports that a 401 auth error came back from Twitter.</p><p>There are two problems here:</p><p>1) The user isn't told how to fix the problem (Go to Settings &gt; Twitter and re-enter user/pass)2) The API does report or return errors</p><p>So neither the developer nor the user are receiving the information they need to improve the situation.</p><p>It's also unclear how this happens in the first place. Settings does not let you save a Twitter account without successfully authenticating, so it sounds like someone is resetting auth tokens after the fact. Whether this is iOS (device-side) or Twitter (server-side) is unclear, but it spans versions and devices. I have other devices that are working just fine with all accounts.</p><p>Verified on:</p><p>iPhone 5, iOS 6.1.4<br>iPhons 5s, iOS 7.0.2</p><p>Steps to Reproduce:<br>1. Add multiple accounts to Settings &gt; Twitter2. Break or expire credentials for one of the accounts (unclear how or why this can happen)3. Try tweeting a photo from Photos / Camera with the broken account</p><p>Expected Results:<br>Expect the tweet to work, or to see actionable information on how to fix the auth problem.</p><p>Actual Results:<br>\"The tweet cannot be sent because the connection to Twitter failed.\" (see attached pic)</p><p>Also attached device log output reporting the 401 auth failure from Twitter.</p><p>Version:<br>iPhone 5, iOS 6.1.4<br>iPhons 5s, iOS 7.0.2</p><p>Notes:<br>Savvy users will be able to experiment and figure out what's wrong, but this could be a lot better on both user and API fronts.</p>",
  "description_updated_by_user_id": 1006184,
  "updated_by_id": null,
  "deleted": false,
  "row_order": 4194304,
  "status": "open",
  "due_on": null
  },
  {
  "type": "Task",
  "created_at": 1417735190,
  "updated_at": 1417735190,
  "id": 15865433,
  "name": "Smart Banners require an App Store installation",
  "task_list_id": 2691300,
  "comments_count": 0,
  "assigned_id": null,
  "is_private": false,
  "project_id": 1332213,
  "urgent": false,
  "user_id": 1006184,
  "position": 0,
  "last_activity_id": 72897661,
  "record_conversion_type": null,
  "record_conversion_id": null,
  "metadata": {},
  "subtasks_count": 0,
  "resolved_subtasks_count": 0,
  "watcher_ids": [
                  1006184
                  ],
  "description": "rdar://15394622\r\n\r\nSummary:\r\niOS 6 Smart Banners only work if the device has an App Store installation of the app in question. To-be-released products, and even Xcode builds of existing products, are not recognized by the smart banner machinery.\r\n\r\nSteps to Reproduce:\r\n0) Uninstall any copies of the app to be tested\r\n1) Build and run your smart-banner-supporting app from Xcode\r\n2) Go to your website with smart banner metadata\r\n3) Note the VIEW button, which takes you to the App Store, rather than OPEN\r\n4) Install the app from the App Store\r\n5) Repeat 1)\r\n\r\nExpected Results:\r\nExpect smart banners to work all the time.\r\n\r\nActual Results:\r\nSmart banners ONLY work after step 5 — specifically after building from Xcode on top of an App Store installation.\r\n\r\nRegression:\r\niOS 6.0 (10A403)\r\n\r\nNotes:\r\nAs far as I can tell, this makes Smart Banner testing completely impossible for pre-1.0 App Store apps. Similarly painful for existing products because the tester now needs the Xcode project and codesign / provisioning. This is a nonstarter for end-user beta testing, but even in many workplaces a QA team may not have source access. IPA installations from the Xcode Organizer do not work. Third-party OTA tools like TestFlight and Hockey are similarly out of luck.\r\n\r\nPlease revise this behavior to work with Debug and Ad-Hoc builds. This should ultimately be linked to the App's Bundle ID on the device side:\r\n\r\n1) Safari reads the app-id parameter from the meta tag\r\n2) Safari contacts the App Store for the related bundle ID\r\n3) Safari asks the system if an app with said bundle ID exists\r\n\r\nThese steps can simply be used as a fallback against the existing current mechanism, rather than replacing it completely.",
  "description_html": "<p>Summary:<br>iOS 6 Smart Banners only work if the device has an App Store installation of the app in question. To-be-released products, and even Xcode builds of existing products, are not recognized by the smart banner machinery.</p><p>Steps to Reproduce:<br>0) Uninstall any copies of the app to be tested1) Build and run your smart-banner-supporting app from Xcode2) Go to your website with smart banner metadata3) Note the VIEW button, which takes you to the App Store, rather than OPEN4) Install the app from the App Store5) Repeat 1)</p><p>Expected Results:<br>Expect smart banners to work all the time.</p><p>Actual Results:<br>Smart banners ONLY work after step 5 — specifically after building from Xcode on top of an App Store installation.</p><p>Regression:<br>iOS 6.0 (10A403)</p><p>Notes:<br>As far as I can tell, this makes Smart Banner testing completely impossible for pre-1.0 App Store apps. Similarly painful for existing products because the tester now needs the Xcode project and codesign / provisioning. This is a nonstarter for end-user beta testing, but even in many workplaces a QA team may not have source access. IPA installations from the Xcode Organizer do not work. Third-party OTA tools like TestFlight and Hockey are similarly out of luck.</p><p>Please revise this behavior to work with Debug and Ad-Hoc builds. This should ultimately be linked to the App's Bundle ID on the device side:</p><p>1) Safari reads the app-id parameter from the meta tag2) Safari contacts the App Store for the related bundle ID3) Safari asks the system if an app with said bundle ID exists</p><p>These steps can simply be used as a fallback against the existing current mechanism, rather than replacing it completely.</p>",
  "description_updated_by_user_id": 1006184,
  "updated_by_id": null,
  "deleted": false,
  "row_order": 6291456,
  "status": "open",
  "due_on": null
  },
  {
  "type": "Task",
  "created_at": 1417735285,
  "updated_at": 1417735285,
  "id": 15865444,
  "name": "Document state of -viewDidLoad in iOS 6+",
  "task_list_id": 2691300,
  "comments_count": 0,
  "assigned_id": null,
  "is_private": false,
  "project_id": 1332213,
  "urgent": false,
  "user_id": 1006184,
  "position": 0,
  "last_activity_id": 72897737,
  "record_conversion_type": null,
  "record_conversion_id": null,
  "metadata": {},
  "subtasks_count": 0,
  "resolved_subtasks_count": 0,
  "watcher_ids": [
                  1006184
                  ],
  "description": "rdar://15394622\r\n\r\nPlease update the -[UIViewController viewDidLoad] reference to explain that method's role in the view lifecycle. With -viewDidUnload dead, it seems like -viewDidUnload will never be called more than once for a given view controller. If that's true, it would be nice to know. If that's NOT true, we need to know when and why that could happen, especially now that we've lost the parity that -viewDidUnload brought.\r\n\r\nDevs are probably assuming this (that it's now effectively a postponed initializer) right now. We need a formal confirmation/denial of the situation in iOS 6 or later.",
  "description_html": "<p>Please update the -[UIViewController viewDidLoad] reference to explain that method's role in the view lifecycle. With -viewDidUnload dead, it seems like -viewDidUnload will never be called more than once for a given view controller. If that's true, it would be nice to know. If that's NOT true, we need to know when and why that could happen, especially now that we've lost the parity that -viewDidUnload brought.</p><p>Devs are probably assuming this (that it's now effectively a postponed initializer) right now. We need a formal confirmation/denial of the situation in iOS 6 or later.</p>",
  "description_updated_by_user_id": 1006184,
  "updated_by_id": null,
  "deleted": false,
  "row_order": 7340032,
  "status": "open",
  "due_on": null
  }
  ]